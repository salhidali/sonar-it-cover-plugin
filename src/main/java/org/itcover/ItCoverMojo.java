package org.itcover;

import java.io.File;
import java.io.IOException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;

import org.apache.commons.lang.StringUtils;
import org.apache.http.auth.AuthenticationException;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.w3c.dom.DOMException;
import org.xml.sax.SAXException;


/*
 * Echos an object string to the output screen.
 * @goal itcover
 * @requiresProject false
 */

@Mojo(name="itcover")
public class ItCoverMojo extends AbstractMojo
{

	private static final String CUSTOM_MEASURES_ATTRIBUTE = "customMeasures";

	private static final String COMPONENT_ATTRIBUTE = "component";

	private static final String ID_ATTRIBUTE = "id";

	private static final String API_CUSTOM_MEASURES_CREATE_URI = "/api/custom_measures/create?metricKey=";

	private static final String API_CUSTOM_MEASURES_UPDATE_URI = "/api/custom_measures/update?id=";

	private static final String API_CUSTOM_MEASURES_SEARCH_METRIC_URI = "/api/custom_measures/search?metric=";

	private static final String API_COMPONENTS_SHOW_COMPONENT_URI = "/api/components/show?component=";

	private static final String EMPTY_STRING = "";

	/**
	 * @parameter default-value="${project.groupId}:${project.artifactId}" expression="${itcover.project}"
	 */
	@Parameter(property = "itcover.project", defaultValue = "${project.groupId}:${project.artifactId}")
	private String project;

	/**
	 * Sonar custom measure that would be modified
	 * @parameter default-value="it_coverage" expression="${itcover.metricKey}"
	 */
	@Parameter(property = "itcover.metricKey", defaultValue = "it_coverage")
	private String metricKey;
	
	/**
	 * Sonar URL (No default value defined)
	 * @parameter expression="${itcover.sonarUrl}"
	 */
	@Parameter(property = "itcover.sonarUrl")
	private String sonarUrl;
	
	/**
	 * Sonar token : If this property is defined, it will be used, otherwise, we will use username and password parameters.
	 * @parameter expression="${itcover.sonarToken}"
	 */
	@Parameter(property = "itcover.sonarToken")
	private String sonarToken;
	
	/**
	 * Sonar username
	 * @parameter default-value="admin" expression="${itcover.sonarUsername}"
	 */
	@Parameter(property = "itcover.sonarUsername", defaultValue = "admin")
	private String sonarUsername;
	
	/**
	 * Sonar password
	 * @parameter default-value="admin" expression="${itcover.sonarPassword}"
	 */
	@Parameter(property = "itcover.sonarPassword", defaultValue = "admin")
	private String sonarPassword;

	/**
	 * The project basedir (Used for report generation)
	 *@parameter default-value="${basedir}"
	 */
	@Parameter(property = "itcover.basedir", defaultValue = "${basedir}")
	private File basedir;
	
	/**
	 * Execution Data File (generated by jacoco)
	 * @parameter default-value="${project.build.directory}/jacoco-it.exec" expression="${itcover.executionDataFile}"
	 */
	@Parameter(property = "itcover.executionDataFile", defaultValue = "${project.build.directory}/jacoco-it.exec")
	private File executionDataFile;
	
	/**
     * The directory containing generated classes of the project being tested. This will be included after the test
     * classes in the test classpath.
     *
     * @parameter default-value="${project.build.outputDirectory}"
     */
	@Parameter(defaultValue = "${project.build.outputDirectory}")
	private File classesDirectory;
	
	/**
     * The source directory containing class sources.
     *
     * @parameter default-value="${project.build.sourceDirectory}"
     */
	@Parameter(defaultValue = "${project.build.sourceDirectory}")
	private File sourceDirectory;
	
	/**
	 * The generated report file that would be used to compute coverage
	 * @parameter default-value="${project.build.directory}/it-cover.xml" expression="${itcover.reportFile}"
	 */
	@Parameter(property = "itcover.reportFile", defaultValue = "${project.build.directory}/it-cover.xml")
	private File reportFile;
	
	/**
	 * Indicates wether or not force the build to fail when there is an error during the execution of the plugin
	 * @parameter default-value="false" expression="${itcover.coverPluginFailureIgnore}"
	 */
	@Parameter(property = "itcover.coverPluginFailureIgnore", defaultValue = "false")
	private boolean coverPluginFailureIgnore;
	
	
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void execute() throws MojoExecutionException, MojoFailureException {

		getLog().info("IT cover plugin : START");
		String javaVersion = System.getProperty("java.version");
		getLog().info("Using Java version : "+javaVersion);
		CloseableHttpClient client = HttpClients.createDefault();
		
		try {
			//Check wether or not the project exists in sonar before proceeding to the coverage compute and update
			HttpGet projectGet = new HttpGet(sonarUrl+API_COMPONENTS_SHOW_COMPONENT_URI+project);
			
			ResponseHandler responseHandler = (ResponseHandler) new JSONResponseHandler();
			JSONObject responseBody = (JSONObject) client.execute(projectGet, responseHandler);
			
			JSONObject component = (JSONObject) responseBody.get(COMPONENT_ATTRIBUTE);
			
			if(null == component) {
				getLog().error("The requested sonar project does not exist.");
				return;
			} 
			HttpGet httpGet = new HttpGet(sonarUrl+API_CUSTOM_MEASURES_SEARCH_METRIC_URI+metricKey+"&projectKey="+project);
			responseBody = (JSONObject) executeHttpQuery(client, httpGet, responseHandler);
			JSONArray customMeasure = (JSONArray) responseBody.get(CUSTOM_MEASURES_ATTRIBUTE);
			
			getLog().debug(responseBody.toJSONString());
			// Check if the custom measure exists in the sonar projects 
			if(null != customMeasure && !customMeasure.isEmpty()) {// Update the custom measure if it exists
				String id = (String) ((JSONObject) customMeasure.get(0)).get(ID_ATTRIBUTE);
				String updateUrl = sonarUrl+API_CUSTOM_MEASURES_UPDATE_URI+id+"&value="+getCoverage();
				HttpPost updatePost = new HttpPost(updateUrl);
				responseBody = (JSONObject) executeHttpQuery(client, updatePost, responseHandler);
				getLog().debug(responseBody.toJSONString());
				if(StringUtils.isEmpty((String) responseBody.get(ID_ATTRIBUTE)) || !id.equals((String) responseBody.get(ID_ATTRIBUTE))) {
					getLog().info("Updating sonar custom metric failed.");
				} else {
					getLog().info("Sonar custom metric updated successfully : "+ updateUrl);
				}
			} else {// Create the custom measure with the coverage value if it does not exist
				String createUrl = sonarUrl+API_CUSTOM_MEASURES_CREATE_URI+metricKey+"&projectKey="+project+"&value="+getCoverage();
				HttpPost createPost = new HttpPost(createUrl);
				responseBody = (JSONObject) executeHttpQuery(client, createPost, responseHandler);
				getLog().debug(responseBody.toJSONString());
				if(StringUtils.isEmpty((String) responseBody.get(ID_ATTRIBUTE))) {
					getLog().info("Creating sonar custom metric failed.");
				} else {
					getLog().info("Sonar custom metric created successfully : "+createUrl);
				}
			}
		}
		catch (IOException e) {
			processException(e);
		}
		catch (AuthenticationException e) {
			processException(e);
		}
		catch (ParserConfigurationException e) {
			processException(e);
		}
		catch (SAXException e) {
			processException(e);
		}
		finally {
			try {
				client.close();
			}
			catch (IOException e) {
				// ignore
			}
		}
		getLog().info("IT cover plugin : END");
	}

	/**
	 * This method handles all types of exception by logging the error and depending on the user choice forcing the build failure.
	 * 
	 * @param Exception
	 * @throws MojoFailureException
	 */
	private void processException(Exception e) throws MojoFailureException {
		getLog().error(e);
		if (!coverPluginFailureIgnore) {
			throw new MojoFailureException(e.getMessage());
		}
	}
	
	private <T> T executeHttpQuery(final CloseableHttpClient client, final HttpUriRequest httpRequest, final ResponseHandler<? extends T> responseHandler) throws IOException, AuthenticationException {
		BasicScheme basicScheme = new BasicScheme();
		UsernamePasswordCredentials creds;
		if(sonarToken != null) {
			creds = new UsernamePasswordCredentials(sonarToken, EMPTY_STRING);
		} else {
			creds = new UsernamePasswordCredentials(sonarUsername, sonarPassword);
		}
		
		httpRequest.addHeader(basicScheme.authenticate(creds, httpRequest, null));
		return client.execute(httpRequest, responseHandler);
	}
	
	private double getCoverage() throws ParserConfigurationException, SAXException, IOException, MojoFailureException {
		final ReportGenerator generator = new ReportGenerator(basedir, executionDataFile, classesDirectory, sourceDirectory,	reportFile);
		generator.create();
		return computeCoverageFromXml(reportFile);
	}
	
	public double computeCoverageFromXml(File reportFile) throws MojoFailureException {
		
		double coverage = 0;
		try {
	         SAXParserFactory factory = SAXParserFactory.newInstance();
	         SAXParser parser = factory.newSAXParser();
	         parser.getXMLReader().setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
	         XMLCoverHandler xmlCoverHandler = new XMLCoverHandler();
	         parser.parse(reportFile.getAbsolutePath(), xmlCoverHandler);
	         
	         coverage = xmlCoverHandler.getCoverage();
	         
	      } catch (DOMException e) {
	    	  processException(e);
	      } catch (ParserConfigurationException e) {
	    	  processException(e);
	      } catch (TransformerFactoryConfigurationError e) {
	    	  getLog().error(e.getMessage());
	      } catch (SAXException e) {
	    	  processException(e);
	      } catch (IOException e) {
	         // TODO Auto-generated catch block
	    	  processException(e);
	      }
		
		return coverage;
	}
 }
